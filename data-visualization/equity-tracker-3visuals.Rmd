---
title: "Visuals for Equity Tracker"
author: "Mary Richards"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    keep_md: yes
    df_print: paged
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '6'
---

```{r rmarkdown setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, 
                      warning=FALSE, 
                      message=FALSE) # formatting
```

```{r library setup, include=FALSE}
# devtools::install_github("psrc/psrcplot",
#                          force=TRUE)
library(tidyverse)
library(psrcelmer)
library(psrccensus)
library(psrcplot)
library(psrctrends)
library(rlang) #required for psrccensus
library(emmeans) #required for rlang
library(magrittr)
library(kableExtra)
library(ggplot2)

library(summarytools) #freq
library(vtable) #summary stats
library(table1)  #nice descriptive summary table
library(scales) #number formatting
library(ggpubr) #graphing - ggarrange fx
library(forcats) #for factor re-leveling
library(plotly) #for interactive charts

library(odbc) #connect to ElmerGeo
library(DBI) #connect to ElmerGeo
library(sf)
library(leaflet)
library(leafem) #home button
library(htmlwidgets) #save visuals as html
library(raster)
library(ggspatial)
library(lubridate) #year formatting
library(stringr) #add leading zero's
library(reshape2) #formatting data
library(readxl)
library(RColorBrewer)
library(gridExtra)

install_psrc_fonts()
library(showtext) #trying to fix PSRC font issues
library(sysfonts) #required for showtext
library(showtextdb) #required for showtext

library(echarts)
library(echarts4r)
# remotes::install_github("JohnCoene/echarts",
#                         force=TRUE)
# remotes::install_github("JohnCoene/echarts4r",
#                         force=TRUE)
library(echarts4r.assets)
```

# 3 visuals for webpage
This code will help produce the three visuals that are going to be a part of each equity tracker indicator webpage: regional map (tract level) of most recent data, chart of the most recent data, chart of trends over time. The inputs/variables will need to be adjusted depending on the indicator characteristics - data source and value type. 

## 1. Map of most recent data
To create the map of the most recent data, there are two different approaches that will depend on the indicator's data source. 

a.) *If the indicator is a PUMS/OPSI indicator that can be accessed through Elmer.* If this is the case, it requires accessing data at the regional/tract level from ACS since the Elmer dataset is already aggregated to equity group/quintile. If this is the case, please start adjusting the code around line 190. 

b.) *If the indicator is available through a tract-level data set.* Getting the data to a workable version may require some data transformation. To map data in this form, there should be a value corresponding to each census tract. Depending on the year of the data, this could be 700 rows for data at 2010 census tracts, or 900 rows for data at 2020 census tracts. If this is the case, please start adjusting the code around line 320.
```{r legend settings, include=FALSE}
# https://stackoverflow.com/questions/40276569/reverse-order-in-r-leaflet-continuous-legend - to get legend high-low with correct color order
addLegend_decreasing <- function (map, position = c("topright", "bottomright", "bottomleft", 
			    "topleft"), pal, values, na.label = "NA", bins = 7, colors, 
		  opacity = 0.5, labels = NULL, labFormat = labelFormat(), 
		  title = NULL, className = "info legend", layerId = NULL, 
		  group = NULL, data = getMapData(map), decreasing = FALSE) {
	position <- match.arg(position)
	type <- "unknown"
	na.color <- NULL
	extra <- NULL
	if (!missing(pal)) {
		if (!missing(colors)) 
			stop("You must provide either 'pal' or 'colors' (not both)")
		if (missing(title) && inherits(values, "formula")) 
			title <- deparse(values[[2]])
		values <- evalFormula(values, data)
		type <- attr(pal, "colorType", exact = TRUE)
		args <- attr(pal, "colorArgs", exact = TRUE)
		na.color <- args$na.color
		if (!is.null(na.color) && col2rgb(na.color, alpha = TRUE)[[4]] == 
		    0) {
			na.color <- NULL
		}
		if (type != "numeric" && !missing(bins)) 
			warning("'bins' is ignored because the palette type is not numeric")
		if (type == "numeric") {
			cuts <- if (length(bins) == 1) 
				pretty(values, bins)
			else bins	
			
			if (length(bins) > 2) 
				if (!all(abs(diff(bins, differences = 2)) <= 
				         sqrt(.Machine$double.eps))) 
					stop("The vector of breaks 'bins' must be equally spaced")
			n <- length(cuts)
			r <- range(values, na.rm = TRUE)
			cuts <- cuts[cuts >= r[1] & cuts <= r[2]]
			n <- length(cuts)
			p <- (cuts - r[1])/(r[2] - r[1])
			extra <- list(p_1 = p[1], p_n = p[n])
			p <- c("", paste0(100 * p, "%"), "")
			if (decreasing == TRUE){
				colors <- pal(rev(c(r[1], cuts, r[2])))
				labels <- rev(labFormat(type = "numeric", cuts))
			}else{
				colors <- pal(c(r[1], cuts, r[2]))
				labels <- rev(labFormat(type = "numeric", cuts))
			}
			colors <- paste(colors, p, sep = " ", collapse = ", ")
			
		}
		else if (type == "bin") {
			cuts <- args$bins
			n <- length(cuts)
			mids <- (cuts[-1] + cuts[-n])/2
			if (decreasing == TRUE){
				colors <- pal(rev(mids))
				labels <- rev(labFormat(type = "bin", cuts))
			}else{
				colors <- pal(mids)
				labels <- labFormat(type = "bin", cuts)
			}
			
		}
		else if (type == "quantile") {
			p <- args$probs
			n <- length(p)
			cuts <- quantile(values, probs = p, na.rm = TRUE)
			mids <- quantile(values, probs = (p[-1] + p[-n])/2, 
				 na.rm = TRUE)
			if (decreasing == TRUE){
				colors <- pal(rev(mids))
				labels <- rev(labFormat(type = "quantile", cuts, p))
			}else{
				colors <- pal(mids)
				labels <- labFormat(type = "quantile", cuts, p)
			}
		}
		else if (type == "factor") {
			v <- sort(unique(na.omit(values)))
			colors <- pal(v)
			labels <- labFormat(type = "factor", v)
			if (decreasing == TRUE){
				colors <- pal(rev(v))
				labels <- rev(labFormat(type = "factor", v))
			}else{
				colors <- pal(v)
				labels <- labFormat(type = "factor", v)
			}
		}
		else stop("Palette function not supported")
		if (!any(is.na(values))) 
			na.color <- NULL
	}
	else {
		if (length(colors) != length(labels)) 
			stop("'colors' and 'labels' must be of the same length")
	}
	legend <- list(colors = I(unname(colors)), labels = I(unname(labels)), 
	               na_color = na.color, na_label = na.label, opacity = opacity, 
	               position = position, type = type, title = title, extra = extra, 
	               layerId = layerId, className = className, group = group)
	invokeMethod(map, data, "addLegend", legend)
}
```

### a) using PUMS/OSPI data from Elmer
```{r, include=FALSE}
# Connecting to ElmerGeo for census geographies through Portal----
tracts20.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2020/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"
# tracts10.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2010/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"

tracts20.lyr<-st_read(tracts20.url)
# tracts10.lyr<-st_read(tracts10.url)

nrow(tracts20.lyr) #919
# nrow(tracts10.lyr) #773
```

```{r}
# Finding the corresponding ACS table - this works if you know the correct concept label. If not, another option would be to visit https://data.census.gov/table and search for the right subject table and skip to the next step----
x <- tidycensus::load_variables(2021,"acs5") %>% 
  dplyr::filter(grepl("median household income",
                      concept, ignore.case=TRUE) & 
                  (geography=="tract"))

# getting data by tract
acs_data <- get_acs_recs(geography ='tract', 
                         table.names = 'B19013', #subject table code
                         years = c(2021),
                         acs.type = 'acs5')

# getting population data by tract - this is to be able to calculate regional/weighted value for call outs
acs_population <- get_acs_recs(geography ='tract',
                      table.names = 'B01003',
                      years = c(2021),
                      acs.type = 'acs5') %>%
  dplyr::rename(pop21=estimate)

# merge median income data with population data
acs_pop <- merge(acs_data, acs_population,
                 by.x = "GEOID",
                 by.y = "GEOID")

# merge to 2020 census tract spatial file
acs_data_tract <- merge(tracts20.lyr, acs_pop,
                        by.x="geoid20",
                        by.y="GEOID",
                        all.x=TRUE)
```

```{r map-1y}
# setting map extent
map.lat<- 47.615
map.lon<- -122.257
map.zoom<- 8.5

# setting color palette
psrc_palette <- leaflet::colorNumeric(palette = psrc_colors$purples_inc,
                                      domain = acs_data_tract$estimate) # this is the value field

# setting the legend/label variables
var_name <- "Median Household <br> Income (2021 USD)" # the <br> could be adjusted depending on the length/spacing of the name
labels <- sprintf(
  "Census tract: <em>%s</em><br/><strong>%s</strong>", acs_data_tract$geoid20, # the code in <> makes the geoid value italic
  paste("$",
        prettyNum((round(acs_data_tract$estimate, digits=-2)),
                  big.mark = ","))) %>%
  lapply(htmltools::HTML)

# if the label required a suffix instead of a prefix, for example a %, the code would look like this:
# labels <- sprintf(
#   "Census tract: <em>%s</em><br/><strong>%s</strong>", acs_data_tract$geoid20,
#   paste(prettyNum((round(acs_data_tract$estimate, digits=2)), #the digits would probably be 2 for %
#               big.mark = ","), #this wouldn't be necessary to include for %s    
#         '%')) %>%
#   lapply(htmltools::HTML)


# map settings
acs_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  addPolygons(data=acs_data_tract,
              fillColor = psrc_palette(acs_data_tract$estimate),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = var_name,
              label = labels) %>% 

  # legend
  addLegend_decreasing(pal = psrc_palette,
                       values = acs_data_tract$estimate,
                       position = "bottomright",
                       title = var_name,
                       group = var_name,
                       opacity = 0.7,
                       labFormat = labelFormat(prefix = "$"),
                       decreasing = TRUE) %>% #to get legend high-low with correct color order
  
  # set view extent
  leaflet::setView(lng=map.lon, lat=map.lat, zoom=map.zoom) %>% 
  addEasyButton(easyButton(
    icon="fa-globe", #htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  &#127760;  
    title="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fixing the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix) # Convert CSS to HTML
acs_map %<>% htmlwidgets::prependContent(html_fix) # Insert into leaflet HTML code

# printing map
acs_map
```

```{r}
website_dev_folder <- '//WEB/website_data/equity-tracker-webpages/economy/med-income/'
map_name <- 'medinc20.html'
  
# interactive webpage output process
htmlwidgets::saveWidget(acs_map,
                        file=paste0(website_dev_folder, map_name))
```

```{r}
# calculate call out information
calc <- acs_data_tract %>% 
  dplyr::mutate(inc_wt_pop = pop21*estimate) %>% 
  dplyr::mutate(reg_medinc = sum(inc_wt_pop, na.rm=TRUE)/sum(pop21, na.rm=TRUE))

# regional median income: 104506.3

sort <- acs_data_tract %>% 
  dplyr::arrange(desc(estimate))

# 53033004101 (Seattle), 53033023902 (Clyde Hill, Yarrow Point, Hunts Point), 53033024100 (Bellevue), 53033024601 (Mercer Island), 53033024602 (Mercer Island)

sort <- acs_data_tract %>% 
  dplyr::arrange(estimate)

# 53033005304 (Seattle UW), 53033005305 (Seattle UW), 53053061601 (Tacoma)
# 53033030501 (Auburn, around 167)
```
\
\

### b) using tract level data from other source
```{r, include=FALSE}
# Connecting to ElmerGeo for census geographies through Portal----
tracts20.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2020/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"
# tracts10.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2010/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"

tracts20.lyr<-st_read(tracts20.url)
# tracts10.lyr<-st_read(tracts10.url)

nrow(tracts20.lyr) #919
# nrow(tracts10.lyr) #773
```

```{r, include=FALSE}
# accessing data from folder/csv
folder_path <- "Y:/Equity Indicators/experimenting/R-scripts/WTN/data-from-WTN/life_expectancy_over_time/"
life_expec_16_20 <- read.csv(paste0(folder_path,"Life_Expectancy_at_Birth_16_20.csv"))

# Elmer crosswalk data set (this step is only necessary if the data that you are using are in 2010 census geographies, instead of 2020)
crosswalk_10_20 <- get_table(schema="census",
                             tbl_name="v_geo_relationships_tracts")

# because its a state data set we need to filter for the census tracts we want to visualize - those in our four-county region
life_expec_16_20 <- life_expec_16_20 %>% 
  mutate(year=2020) %>% 
  filter(County.Name=="King" |
           County.Name=="Kitsap" |
           County.Name=="Pierce" |
           County.Name=="Snohomish")

# join WTN health data (in 2010 census tracts) to cross walk
health_risk_crosswalk <- merge(crosswalk_10_20, life_expec_16_20,
                               by.x="geoid10",
                               by.y="Census.Tract", 
                               all.x=TRUE)

# join WTN health data/crosswalk to equity quintiles (on 2020 census tracts)
# health_risk_equity_tracts <- merge(health_risk_crosswalk, equity_tracts_20,
#                                    by.x="geoid20",
#                                    by.y="geoid", 
#                                    all.x=TRUE)


health_risk_crosswalk <- health_risk_crosswalk %>% 
  dplyr::mutate(data_year=format(year.x,format="%Y")) %>% 
  dplyr::mutate(Life.Expectancy_num=as.numeric(Life.Expectancy))

# simplify data
# colnames(health_equity_quintiles20)

health_ind_20 <- health_risk_crosswalk %>% 
  dplyr::select(GEOID, estimate, data_year, geoid10, 
                County.Name, Life.Expectancy, 
                Life.Expectancy_num) 

# merge to 2020 census tract spatial file
health_risk_tract20 <- merge(tracts20.lyr, health_ind_20,
                             by.x="geoid20",
                             by.y="GEOID", 
                             all.x=TRUE) %>% 
  dplyr::mutate(pop_density = estimate/(Shape__Area*3.861e-7))

# check/remove NAs
# summary(health_risk_tract20$Life.Expectancy_num)
```

```{r mapping health indicator risk}
# set map extent
map.lat<- 47.615
map.lon<- -122.257
map.zoom<- 8.5

# set up palettes
health_pal <- leaflet::colorNumeric(palette=psrc_colors$purples_inc,
                                    domain = health_risk_tract20$Life.Expectancy_num)

# set the variable
var_name <- "Life Expectancy"
labels <- sprintf(
  "Census tract: <em>%s</em><br/><strong>%s</strong>",
  health_risk_tract20$geoid20, paste(prettyNum((round(health_risk_tract20$Life.Expectancy_num, digits=1))), " years")) %>% 
  lapply(htmltools::HTML)

# map settings
healthrisk_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  addPolygons(data=health_risk_tract20,
              fillColor = health_pal(health_risk_tract20$Life.Expectancy_num),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = var_name,
              # label = round(health_risk_tract20$Life.Expectancy_num, digits=1),
              label = labels) %>%

  # legends
  addLegend_decreasing(pal = health_pal,
                       values = health_risk_tract20$Life.Expectancy_num,
                       position = "bottomright",
                       title = var_name,
                       group = var_name,
                       opacity = 0.7,
                       decreasing = TRUE,
                       labFormat = labelFormat())
  
  #set view extent
  leaflet::setView(lng=map.lon, lat=map.lat, zoom=map.zoom) %>% 
  addEasyButton(easyButton(
    icon="fa-globe", title="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
healthrisk_map %<>% htmlwidgets::prependContent(html_fix)

# print map
healthrisk_map
```

```{r}
website_dev_folder <- paste0("//WEB/website_data/equity-tracker-webpages/health/life-expec","/")

# interactive webpage output process
htmlwidgets::saveWidget(healthrisk_map,
                        file=paste0(website_dev_folder, 'life-expec20.html'))
```

```{r, include=FALSE, eval=FALSE}
# calculate call out information
health_equity_quintiles20_calc <- health_equity_quintiles20 %>%
  mutate(life.expectancy.wgt=(sum(Life.Expectancy_num*estimate, na.rm =TRUE))/(sum(estimate, na.rm=TRUE)))
# regional average life expectancy: 78.83183

x<-rep(health_equity_quintiles20_calc$Life.Expectancy_num,times=health_equity_quintiles20_calc$estimate)
df1<-data.frame(x)
summary(df1$x)
median(df1$x, na.rm=TRUE)
hist(df1$x)
# regional median life expectancy: 80.86   

data <- health_risk_tract20 %>%
  st_drop_geometry()

sort <- data %>% 
  dplyr::arrange(desc(Life.Expectancy_num))
# 3 highest: 53053070316 (Auburn) Pierce (95.39), 53033004401 (Roosevelt) and 53033004402 (U-district) King (92.14)

sort <- data %>% 
  dplyr::arrange(Life.Expectancy_num)

# 3 lowest: 53053061900 (Tacoma-Lincoln International District) Pierce (67.31), 53053071806 (Lakewood) Pierce (69.74), (Tulalip Reservation) 53061940002 Snohomish (70.10)

#95.39-67.31=28.08
```