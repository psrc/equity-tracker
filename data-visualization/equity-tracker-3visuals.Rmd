---
title: "Visuals for Equity Tracker"
author: "Mary Richards"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    keep_md: yes
    df_print: paged
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '6'
---

```{r rmarkdown setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, 
                      warning=FALSE, 
                      message=FALSE) # formatting
```

```{r library setup, include=FALSE}
# devtools::install_github("psrc/psrcplot",
#                          force=TRUE)
library(tidyverse)
library(psrcelmer)
library(psrccensus)
library(psrcplot)
library(psrctrends)
library(rlang) #required for psrccensus
library(emmeans) #required for rlang
library(magrittr)
library(kableExtra)
library(ggplot2)

library(summarytools) #freq
library(vtable) #summary stats
library(table1)  #nice descriptive summary table
library(scales) #number formatting
library(ggpubr) #graphing - ggarrange fx
library(forcats) #for factor re-leveling
library(plotly) #for interactive charts

library(odbc) #connect to ElmerGeo
library(DBI) #connect to ElmerGeo
library(sf)
library(leaflet)
library(leafem) #home button
library(htmlwidgets) #save visuals as html
library(raster)
library(ggspatial)
library(lubridate) #year formatting
library(stringr) #add leading zero's
library(reshape2) #formatting data
library(readxl)
library(RColorBrewer)
library(gridExtra)

install_psrc_fonts()
library(showtext) #trying to fix PSRC font issues
library(sysfonts) #required for showtext
library(showtextdb) #required for showtext

library(echarts)
library(echarts4r)
# remotes::install_github("JohnCoene/echarts",
#                         force=TRUE)
# remotes::install_github("JohnCoene/echarts4r",
#                         force=TRUE)
library(echarts4r.assets)
```

This code will help produce the three visuals that we are going to include on the equity tracker indicator webpages. The inputs will need to be adjusted depending on the indicator characteristics. 


# 3 visuals for webpage
## 1. Map of most recent data
For the map of most recent data, there are two different approaches. 

a.) The first is if the indicator is a PUMS/OPSI indicator that is accessed through Elmer. If this is the case, it requires accessing data at the regional/tract level from ACS since the Elmer dataset is already aggregated to equity group/quintile. If this is the case, please start adjusting the code around line 190. 

b.) The second is easier and applies if the indicator is already available at a tract-level dataset. If this is the case, please start adjusting the code around line 320.
```{r legend settings, include=FALSE}
# https://stackoverflow.com/questions/40276569/reverse-order-in-r-leaflet-continuous-legend - to get legend high-low with correct color order
addLegend_decreasing <- function (map, position = c("topright", "bottomright", "bottomleft", 
			    "topleft"), pal, values, na.label = "NA", bins = 7, colors, 
		  opacity = 0.5, labels = NULL, labFormat = labelFormat(), 
		  title = NULL, className = "info legend", layerId = NULL, 
		  group = NULL, data = getMapData(map), decreasing = FALSE) {
	position <- match.arg(position)
	type <- "unknown"
	na.color <- NULL
	extra <- NULL
	if (!missing(pal)) {
		if (!missing(colors)) 
			stop("You must provide either 'pal' or 'colors' (not both)")
		if (missing(title) && inherits(values, "formula")) 
			title <- deparse(values[[2]])
		values <- evalFormula(values, data)
		type <- attr(pal, "colorType", exact = TRUE)
		args <- attr(pal, "colorArgs", exact = TRUE)
		na.color <- args$na.color
		if (!is.null(na.color) && col2rgb(na.color, alpha = TRUE)[[4]] == 
		    0) {
			na.color <- NULL
		}
		if (type != "numeric" && !missing(bins)) 
			warning("'bins' is ignored because the palette type is not numeric")
		if (type == "numeric") {
			cuts <- if (length(bins) == 1) 
				pretty(values, bins)
			else bins	
			
			if (length(bins) > 2) 
				if (!all(abs(diff(bins, differences = 2)) <= 
				         sqrt(.Machine$double.eps))) 
					stop("The vector of breaks 'bins' must be equally spaced")
			n <- length(cuts)
			r <- range(values, na.rm = TRUE)
			cuts <- cuts[cuts >= r[1] & cuts <= r[2]]
			n <- length(cuts)
			p <- (cuts - r[1])/(r[2] - r[1])
			extra <- list(p_1 = p[1], p_n = p[n])
			p <- c("", paste0(100 * p, "%"), "")
			if (decreasing == TRUE){
				colors <- pal(rev(c(r[1], cuts, r[2])))
				labels <- rev(labFormat(type = "numeric", cuts))
			}else{
				colors <- pal(c(r[1], cuts, r[2]))
				labels <- rev(labFormat(type = "numeric", cuts))
			}
			colors <- paste(colors, p, sep = " ", collapse = ", ")
			
		}
		else if (type == "bin") {
			cuts <- args$bins
			n <- length(cuts)
			mids <- (cuts[-1] + cuts[-n])/2
			if (decreasing == TRUE){
				colors <- pal(rev(mids))
				labels <- rev(labFormat(type = "bin", cuts))
			}else{
				colors <- pal(mids)
				labels <- labFormat(type = "bin", cuts)
			}
			
		}
		else if (type == "quantile") {
			p <- args$probs
			n <- length(p)
			cuts <- quantile(values, probs = p, na.rm = TRUE)
			mids <- quantile(values, probs = (p[-1] + p[-n])/2, 
				 na.rm = TRUE)
			if (decreasing == TRUE){
				colors <- pal(rev(mids))
				labels <- rev(labFormat(type = "quantile", cuts, p))
			}else{
				colors <- pal(mids)
				labels <- labFormat(type = "quantile", cuts, p)
			}
		}
		else if (type == "factor") {
			v <- sort(unique(na.omit(values)))
			colors <- pal(v)
			labels <- labFormat(type = "factor", v)
			if (decreasing == TRUE){
				colors <- pal(rev(v))
				labels <- rev(labFormat(type = "factor", v))
			}else{
				colors <- pal(v)
				labels <- labFormat(type = "factor", v)
			}
		}
		else stop("Palette function not supported")
		if (!any(is.na(values))) 
			na.color <- NULL
	}
	else {
		if (length(colors) != length(labels)) 
			stop("'colors' and 'labels' must be of the same length")
	}
	legend <- list(colors = I(unname(colors)), labels = I(unname(labels)), 
	               na_color = na.color, na_label = na.label, opacity = opacity, 
	               position = position, type = type, title = title, extra = extra, 
	               layerId = layerId, className = className, group = group)
	invokeMethod(map, data, "addLegend", legend)
}
```

### a) using PUMS/OSPI data from Elmer
```{r, include=FALSE}
# Connecting to ElmerGeo for census geographies through Portal----
tracts20.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2020/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"

tracts20.lyr<-st_read(tracts20.url)

nrow(tracts20.lyr) #919
```

```{r}
x <- tidycensus::load_variables(2021,"acs5") %>% 
  dplyr::filter(grepl("MEDIAN HOUSEHOLD INCOME", concept) & (geography=="tract"))

# getting household median income data by tract
medinc21 <- get_acs_recs(geography ='tract', 
                         table.names = 'B19013',
                         years = c(2021),
                         acs.type = 'acs5')

# getting population data by tract
pop21 <- get_acs_recs(geography ='tract',
                      table.names = 'B01003',
                      years = c(2021),
                      acs.type = 'acs5') %>% 
  dplyr::rename(pop21=estimate)

# merge median income data with population data
income_population_21 <- merge(medinc21, pop21,
                              by.x = "GEOID",
                              by.y = "GEOID")

# merge to 2020 census tract spatial file
medinc_tract20 <- merge(tracts20.lyr, income_population_21,
                             by.x="geoid20",
                             by.y="GEOID", 
                             all.x=TRUE) %>% 
  dplyr::mutate(pop_density = pop21/(Shape__Area*3.861e-7))
```

```{r map-1y}
# set map extent
map.lat<- 47.615
map.lon<- -122.257
map.zoom<- 8.5

# set up palettes
health_pal <- leaflet::colorNumeric(palette=psrc_colors$purples_inc,
                                    domain = medinc_tract20$estimate)

# set the variable
var_name <- "Median Household <br> Income (2021 USD)"
labels <- sprintf(
  "Census tract: <em>%s</em><br/><strong>%s</strong>",
  medinc_tract20$geoid20, paste("$",prettyNum((round(medinc_tract20$estimate, digits=-2)), big.mark = ","))) %>% 
  lapply(htmltools::HTML)

# map settings
medinc_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  addPolygons(data=medinc_tract20,
              fillColor = health_pal(medinc_tract20$estimate),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = var_name,
              # label = paste("$",prettyNum((round(medinc_tract20$estimate, digits=-2)), big.mark = ",")),
              label = labels) %>% 

  # legends
  addLegend_decreasing(pal = health_pal,
                     values = medinc_tract20$estimate,
                     position = "bottomright",
                     title = var_name,
                     group = var_name,
                     opacity = 0.7,
                     labFormat = labelFormat(prefix = "$"),
                     decreasing = TRUE) %>% #to get legend high-low with correct color order
  
  #set view extent
  leaflet::setView(lng=map.lon, lat=map.lat, zoom=map.zoom) %>% 
  addEasyButton(easyButton(
    icon="fa-globe", title="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
medinc_map %<>% htmlwidgets::prependContent(html_fix)      # Insert into leaflet HTML code

# print map
medinc_map
```

```{r}
website_dev_folder <- paste0("//WEB/website_data/equity-tracker-webpages/economy/med-income","/")

# interactive webpage output process
htmlwidgets::saveWidget(medinc_map,
                        file=paste0(website_dev_folder, 'medinc20.html'))
```

```{r}
# calculate call out information
calc <- income_population_21 %>% 
  dplyr::mutate(inc_wt_pop = pop21*estimate) %>% 
  dplyr::mutate(reg_medinc = sum(inc_wt_pop, na.rm=TRUE)/sum(pop21, na.rm=TRUE))

# regional median income: 104506.3

sort <- income_population_21 %>% 
  dplyr::arrange(desc(estimate))

# 53033004101 (Seattle), 53033023902 (Clyde Hill, Yarrow Point, Hunts Point), 53033024100 (Bellevue), 53033024601 (Mercer Island), 53033024602 (Mercer Island)

sort <- income_population_21 %>% 
  dplyr::arrange(estimate)

# 53033005304 (Seattle UW), 53033005305 (Seattle UW), 53053061601 (Tacoma)
# 53033030501 (Auburn, around 167)
```

### b) using tract level data from other source
```{r, include=FALSE}
# simplify data
# colnames(health_equity_quintiles20)

health_ind_20 <- health_equity_quintiles20 %>% 
  dplyr::select(GEOID, estimate, data_year, geoid10, 
                County.Name, Life.Expectancy, 
                Life.Expectancy_num) 

# merge to 2020 census tract spatial file
health_risk_tract20 <- merge(tracts20.lyr, health_ind_20,
                             by.x="geoid20",
                             by.y="GEOID", 
                             all.x=TRUE) %>% 
  dplyr::mutate(pop_density = estimate/(Shape__Area*3.861e-7))

# check/remove NAs
# summary(health_risk_tract20$Life.Expectancy_num)
```

```{r mapping health indicator risk}
# set map extent
map.lat<- 47.615
map.lon<- -122.257
map.zoom<- 8.5

# set up palettes
health_pal <- leaflet::colorNumeric(palette=psrc_colors$purples_inc,
                                    domain = health_risk_tract20$Life.Expectancy_num)

# set the variable
var_name <- "Life Expectancy"
labels <- sprintf(
  "Census tract: <em>%s</em><br/><strong>%s</strong>",
  health_risk_tract20$geoid20, paste(prettyNum((round(health_risk_tract20$Life.Expectancy_num, digits=1))), " years")) %>% 
  lapply(htmltools::HTML)

# map settings
healthrisk_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  addPolygons(data=health_risk_tract20,
              fillColor = health_pal(health_risk_tract20$Life.Expectancy_num),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = var_name,
              # label = round(health_risk_tract20$Life.Expectancy_num, digits=1),
              label = labels) %>%

  # legends
  addLegend_decreasing(pal = health_pal,
                       values = health_risk_tract20$Life.Expectancy_num,
                       position = "bottomright",
                       title = var_name,
                       group = var_name,
                       opacity = 0.7,
                       decreasing = TRUE,
                       labFormat = labelFormat())
  
  #set view extent
  leaflet::setView(lng=map.lon, lat=map.lat, zoom=map.zoom) %>% 
  addEasyButton(easyButton(
    icon="fa-globe", title="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
healthrisk_map %<>% htmlwidgets::prependContent(html_fix)

# print map
healthrisk_map
```

```{r}
website_dev_folder <- paste0("//WEB/website_data/equity-tracker-webpages/health/life-expec","/")

# interactive webpage output process
htmlwidgets::saveWidget(healthrisk_map,
                        file=paste0(website_dev_folder, 'life-expec20.html'))
```

```{r, include=FALSE, eval=FALSE}
# calculate call out information
health_equity_quintiles20_calc <- health_equity_quintiles20 %>%
  mutate(life.expectancy.wgt=(sum(Life.Expectancy_num*estimate, na.rm =TRUE))/(sum(estimate, na.rm=TRUE)))
# regional average life expectancy: 78.83183

x<-rep(health_equity_quintiles20_calc$Life.Expectancy_num,times=health_equity_quintiles20_calc$estimate)
df1<-data.frame(x)
summary(df1$x)
median(df1$x, na.rm=TRUE)
hist(df1$x)
# regional median life expectancy: 80.86   

data <- health_risk_tract20 %>%
  st_drop_geometry()

sort <- data %>% 
  dplyr::arrange(desc(Life.Expectancy_num))
# 3 highest: 53053070316 (Auburn) Pierce (95.39), 53033004401 (Roosevelt) and 53033004402 (U-district) King (92.14)

sort <- data %>% 
  dplyr::arrange(Life.Expectancy_num)

# 3 lowest: 53053061900 (Tacoma-Lincoln International District) Pierce (67.31), 53053071806 (Lakewood) Pierce (69.74), (Tulalip Reservation) 53061940002 Snohomish (70.10)

#95.39-67.31=28.08
```