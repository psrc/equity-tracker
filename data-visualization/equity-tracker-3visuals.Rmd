---
title: "Visuals for Equity Tracker"
author: "Mary Richards"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    keep_md: yes
    df_print: paged
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '6'
---

```{r rmarkdown setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, 
                      warning=FALSE, 
                      message=FALSE) # formatting
```

```{r library setup, include=FALSE}
# devtools::install_github("psrc/psrcplot",
#                          force=TRUE)
library(tidyverse)
library(psrcelmer)
library(psrccensus)
library(psrcplot)
library(psrctrends)
library(rlang) #required for psrccensus
library(emmeans) #required for rlang
library(magrittr)
library(kableExtra)
library(ggplot2)

library(summarytools) #freq
library(vtable) #summary stats
library(table1)  #nice descriptive summary table
library(scales) #number formatting
library(ggpubr) #graphing - ggarrange fx
library(forcats) #for factor re-leveling
library(plotly) #for interactive charts

library(odbc) #connect to ElmerGeo
library(DBI) #connect to ElmerGeo
library(sf)
library(leaflet)
library(leafem) #home button
library(htmlwidgets) #save visuals as html
library(raster)
library(ggspatial)
library(lubridate) #year formatting
library(stringr) #add leading zero's
library(reshape2) #formatting data
library(readxl)
library(RColorBrewer)
library(gridExtra)

install_psrc_fonts()
library(showtext) #trying to fix PSRC font issues
library(sysfonts) #required for showtext
library(showtextdb) #required for showtext

library(echarts)
library(echarts4r)
# remotes::install_github("JohnCoene/echarts",
#                         force=TRUE)
# remotes::install_github("JohnCoene/echarts4r",
#                         force=TRUE)
library(echarts4r.assets)
```

# 3 visuals for webpage
This code will help produce the three visuals that are going to be a part of each equity tracker indicator webpage: regional map (tract level) of most recent data, chart of the most recent data, chart of trends over time. The inputs/variables will need to be adjusted depending on the indicator characteristics - data source and value type. 

## 1. Map of most recent data
To create the map of the most recent data, there are two different approaches that will depend on the indicator's data source. 

a.) **If the indicator is a PUMS/OPSI indicator that can be accessed through Elmer.** If this is the case, it requires accessing data at the regional/tract level from ACS since the Elmer dataset is already aggregated to equity group/quintile. If this is the case, please start adjusting the code around line 190. 

b.) **If the indicator is available through a tract-level data set.** Getting the data to a workable version may require some data transformation. To map data in this form, there should be a value corresponding to each census tract. Depending on the year of the data, this could be 700 rows for data at 2010 census tracts, or 900 rows for data at 2020 census tracts. If this is the case, please start adjusting the code around line 320.
```{r legend settings, include=FALSE}
# https://stackoverflow.com/questions/40276569/reverse-order-in-r-leaflet-continuous-legend - this code helps to set up the legend so that it is arranged high-low with correct color order
addLegend_decreasing <- function (map, position = c("topright", "bottomright", "bottomleft", 
			    "topleft"), pal, values, na.label = "NA", bins = 7, colors, 
		  opacity = 0.5, labels = NULL, labFormat = labelFormat(), 
		  title = NULL, className = "info legend", layerId = NULL, 
		  group = NULL, data = getMapData(map), decreasing = FALSE) {
	position <- match.arg(position)
	type <- "unknown"
	na.color <- NULL
	extra <- NULL
	if (!missing(pal)) {
		if (!missing(colors)) 
			stop("You must provide either 'pal' or 'colors' (not both)")
		if (missing(title) && inherits(values, "formula")) 
			title <- deparse(values[[2]])
		values <- evalFormula(values, data)
		type <- attr(pal, "colorType", exact = TRUE)
		args <- attr(pal, "colorArgs", exact = TRUE)
		na.color <- args$na.color
		if (!is.null(na.color) && col2rgb(na.color, alpha = TRUE)[[4]] == 
		    0) {
			na.color <- NULL
		}
		if (type != "numeric" && !missing(bins)) 
			warning("'bins' is ignored because the palette type is not numeric")
		if (type == "numeric") {
			cuts <- if (length(bins) == 1) 
				pretty(values, bins)
			else bins	
			
			if (length(bins) > 2) 
				if (!all(abs(diff(bins, differences = 2)) <= 
				         sqrt(.Machine$double.eps))) 
					stop("The vector of breaks 'bins' must be equally spaced")
			n <- length(cuts)
			r <- range(values, na.rm = TRUE)
			cuts <- cuts[cuts >= r[1] & cuts <= r[2]]
			n <- length(cuts)
			p <- (cuts - r[1])/(r[2] - r[1])
			extra <- list(p_1 = p[1], p_n = p[n])
			p <- c("", paste0(100 * p, "%"), "")
			if (decreasing == TRUE){
				colors <- pal(rev(c(r[1], cuts, r[2])))
				labels <- rev(labFormat(type = "numeric", cuts))
			}else{
				colors <- pal(c(r[1], cuts, r[2]))
				labels <- rev(labFormat(type = "numeric", cuts))
			}
			colors <- paste(colors, p, sep = " ", collapse = ", ")
			
		}
		else if (type == "bin") {
			cuts <- args$bins
			n <- length(cuts)
			mids <- (cuts[-1] + cuts[-n])/2
			if (decreasing == TRUE){
				colors <- pal(rev(mids))
				labels <- rev(labFormat(type = "bin", cuts))
			}else{
				colors <- pal(mids)
				labels <- labFormat(type = "bin", cuts)
			}
			
		}
		else if (type == "quantile") {
			p <- args$probs
			n <- length(p)
			cuts <- quantile(values, probs = p, na.rm = TRUE)
			mids <- quantile(values, probs = (p[-1] + p[-n])/2, 
				 na.rm = TRUE)
			if (decreasing == TRUE){
				colors <- pal(rev(mids))
				labels <- rev(labFormat(type = "quantile", cuts, p))
			}else{
				colors <- pal(mids)
				labels <- labFormat(type = "quantile", cuts, p)
			}
		}
		else if (type == "factor") {
			v <- sort(unique(na.omit(values)))
			colors <- pal(v)
			labels <- labFormat(type = "factor", v)
			if (decreasing == TRUE){
				colors <- pal(rev(v))
				labels <- rev(labFormat(type = "factor", v))
			}else{
				colors <- pal(v)
				labels <- labFormat(type = "factor", v)
			}
		}
		else stop("Palette function not supported")
		if (!any(is.na(values))) 
			na.color <- NULL
	}
	else {
		if (length(colors) != length(labels)) 
			stop("'colors' and 'labels' must be of the same length")
	}
	legend <- list(colors = I(unname(colors)), labels = I(unname(labels)), 
	               na_color = na.color, na_label = na.label, opacity = opacity, 
	               position = position, type = type, title = title, extra = extra, 
	               layerId = layerId, className = className, group = group)
	invokeMethod(map, data, "addLegend", legend)
}
```

### a) using PUMS/OSPI data from Elmer
```{r census tract spatial data, include=FALSE}
# Connecting to ElmerGeo for census geographies through Portal----
tracts20.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2020/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"
tracts10.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2010/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"

tracts20.lyr<-st_read(tracts20.url)
tracts10.lyr<-st_read(tracts10.url)

nrow(tracts20.lyr) #919
nrow(tracts10.lyr) #773
```

```{r data, include=FALSE}
# Finding the corresponding ACS table - this works if you know the correct concept label. If not, another option would be to visit https://data.census.gov/table and search for the right subject table and skip to the next step----
x <- tidycensus::load_variables(2021,"acs5") %>% 
  dplyr::filter(grepl("median household income",
                      concept, ignore.case=TRUE) & 
                  (geography=="tract"))

# getting data by tract
acs_data <- get_acs_recs(geography ='tract', 
                         table.names = 'B19013', #subject table code
                         years = c(2021),
                         acs.type = 'acs5')

# you may need to do some additional data wrangling to get the acs data into the desired format - for example, aggregating education attainment to two categories - less than bachelor's and bachelors and higher 


# getting population data by tract - this is to be able to calculate regional/weighted value for call outs
acs_population <- get_acs_recs(geography ='tract',
                      table.names = 'B01003',
                      years = c(2021),
                      acs.type = 'acs5') %>%
  dplyr::rename(pop21=estimate)

# merge median income data with population data
acs_pop <- merge(acs_data, acs_population,
                 by.x = "GEOID",
                 by.y = "GEOID")

# merge to 2020 census tract spatial file
acs_data_tract <- merge(tracts20.lyr, acs_pop,
                        by.x="geoid20",
                        by.y="GEOID",
                        all.x=TRUE)
```

```{r map}
# setting map extent
map.lat<- 47.615
map.lon<- -122.257
map.zoom<- 8.5

# setting color palette
psrc_palette <- leaflet::colorNumeric(palette = psrc_colors$purples_inc,
                                      domain = acs_data_tract$estimate) # this is the value field

# setting the legend/label variables
var_name <- "Median Household <br> Income (2021 USD)" # the <br> could be adjusted depending on the length/spacing of the name
labels <- sprintf(
  "Census tract: <em>%s</em><br/><strong>%s</strong>", acs_data_tract$geoid20, # the code in <> makes the geoid value italic
  paste("$", # if doesn't require prefix, this can be removed
        prettyNum((round(acs_data_tract$estimate, digits=-2)),
                  big.mark = ","))) %>%
  lapply(htmltools::HTML)

# if the label required a suffix instead of a prefix, for example a %, the code would look like this:
# labels <- sprintf(
#   "Census tract: <em>%s</em><br/><strong>%s</strong>", acs_data_tract$geoid20,
#   paste(prettyNum((round(acs_data_tract$estimate, digits=2)), #the digits would probably be 2 for %
#               big.mark = ","), #this wouldn't be necessary to include for %s    
#         '%')) %>%
#   lapply(htmltools::HTML)


# map settings
acs_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  addPolygons(data=acs_data_tract,
              fillColor = psrc_palette(acs_data_tract$estimate),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = var_name,
              label = labels) %>% 

  # legend
  addLegend_decreasing(pal = psrc_palette,
                       values = acs_data_tract$estimate,
                       position = "bottomright",
                       title = var_name,
                       group = var_name,
                       opacity = 0.7,
                       labFormat = labelFormat(prefix = "$"),
                       decreasing = TRUE) %>% #to get legend high-low with correct color order
  
  # set view extent
  leaflet::setView(lng=map.lon, lat=map.lat, zoom=map.zoom) %>% 
  addEasyButton(easyButton(
    icon = htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  #&#127760; (another emoji option) #"fa-globe", (font awesome icon no longer works because of the conversion to Poppins font below)  
    title ="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fixing the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix) # Convert CSS to HTML
acs_map %<>% htmlwidgets::prependContent(html_fix) # Insert into leaflet HTML code

# printing map
acs_map
```

```{r, include=FALSE}
website_dev_folder <- '//WEB/website_data/equity-tracker-webpages/economy/med-income/'
map_name <- 'medinc20.html'
  
# interactive webpage output process
htmlwidgets::saveWidget(acs_map,
                        file=paste0(website_dev_folder, map_name))
```
\
\

#### Data call outs
```{r, include=FALSE, eval=FALSE}
# calculate call out information
calc <- acs_data_tract %>% 
  dplyr::mutate(inc_wt_pop = pop21*estimate) %>% 
  dplyr::mutate(reg_medinc = sum(inc_wt_pop, na.rm=TRUE)/sum(pop21, na.rm=TRUE))

# regional median income: 104506.3

sort <- acs_data_tract %>% 
  dplyr::arrange(desc(estimate))

# 53033004101 (Seattle), 53033023902 (Clyde Hill, Yarrow Point, Hunts Point), 53033024100 (Bellevue), 53033024601 (Mercer Island), 53033024602 (Mercer Island)

sort <- acs_data_tract %>% 
  dplyr::arrange(estimate)

# 53033005304 (Seattle UW), 53033005305 (Seattle UW), 53053061601 (Tacoma)
# 53033030501 (Auburn, around 167)
```

1. $104,500: The region's median household income
2. $250,000: The highest median income for five tracts in Seattle, Mercer Island, Bellevue, Clyde Hill, Yarrow Point, and Hunts Point
3. $21,000: The lowest median income in the region

\

#### Insights & Analysis

* 
* 
* 
* 

\
\

### b) using tract level data from other source
```{r census tract spatial data, include=FALSE}
# Connecting to ElmerGeo for census geographies through Portal----
tracts20.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2020/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"
tracts10.url <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services/Census_Tracts_2010/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"

tracts20.lyr<-st_read(tracts20.url)
tracts10.lyr<-st_read(tracts10.url)

nrow(tracts20.lyr) #919
nrow(tracts10.lyr) #773
```

```{r data, include=FALSE}
# accessing tract-level data from folder/csv
folder_path <- "Y:/Equity Indicators/experimenting/R-scripts/WTN/data-from-WTN/life_expectancy_over_time/"
data_csv <- read.csv(paste0(folder_path,"Life_Expectancy_at_Birth_16_20.csv"))

# any data transformations that you need to do - any issues that you may have found through the exploration step should be applied here
head(data_csv) # to look through data set
nrow(data_csv) # check number of tracts available - if more than the expected number (700 or 900), it could be more tracts than the region or multiple years

# for example, because this is a state data set we need to filter for the census tracts we want to visualize - those in our four-county region, and for this map we want to show the most recent data available
data_csv <- data_csv %>% 
  mutate(year=2020) %>% 
  filter(County.Name=="King" |
           County.Name=="Kitsap" |
           County.Name=="Pierce" |
           County.Name=="Snohomish")
```

```{r, include=FALSE}
# # Elmer crosswalk data set (this step is only necessary if the data that you are using are in 2010 census geographies, instead of 2020)
# crosswalk_10_20 <- get_table(schema="census",
#                              tbl_name="v_geo_relationships_tracts")
# 
# # join cleaned tract-level data (in 2010 census tracts) to cross walk (comment out this step if the data is already in 2020 geographies)
# data_crosswalk <- merge(crosswalk_10_20, data_csv,
#                         by.x="geoid10",
#                         by.y="Census.Tract", # this will need to be adjusted based on the field name
#                         all.x=TRUE)
```

```{r, include=FALSE}
# cleaning data (if the crosswalk WAS required)
# data_set <- data_crosswalk %>% 
#   dplyr::mutate(data_year=format(year,format="%Y")) %>% 
#   dplyr::mutate(estimate=as.numeric(Life.Expectancy)) # rename value variable for consistency

# cleaning data (if the crosswalk WAS NOT required)
data_set <- data_csv %>%
  dplyr::mutate(data_year=format(year,format="%Y")) %>%
  dplyr::mutate(estimate=as.numeric(Life.Expectancy)) # rename value variable for consistency

```

```{r, include=FALSE}
# simplify data by selecting only those necessary for mapping
colnames(data_set)

data_set <- data_set %>% 
  dplyr::select(Census.Tract, data_year, 
                County.Name, Life.Expectancy, 
                estimate) 

# merge to census tract spatial file
data_tract <- merge(tracts10.lyr, data_set,
                    by.x="geoid10",
                    by.y="Census.Tract", # this will need to be adjusted based on the field name 
                    all.x=TRUE) %>% 
  dplyr::mutate(pop_density_mi2 = total_pop10/(Shape__Area*3.861e-7))

# check/remove NAs
# summary(health_risk_tract20$estimate)
```

```{r map}
# set map extent
map.lat<- 47.615
map.lon<- -122.257
map.zoom<- 8.5

# set up palettes
psrc_palette <- leaflet::colorNumeric(palette=psrc_colors$purples_inc,
                                      domain = data_tract$estimate)

# set the variable
var_name <- "Life Expectancy"
labels <- sprintf(
  "Census tract: <em>%s</em><br/><strong>%s</strong>", data_tract$geoid10, # the code in <> makes the geoid value italic 
  paste(prettyNum((round(data_tract$estimate, digits=1))), " years")) %>% 
  lapply(htmltools::HTML)

# if the label required a prefix, for example a $, the code would look like this:
# labels <- sprintf(
#   "Census tract: <em>%s</em><br/><strong>%s</strong>", data_tract$Census.Tract, # the code in <> makes the geoid value italic
#   paste("$",
#         prettyNum((round(data_tract$estimate, digits=-2)),
#                   big.mark = ","))) %>%
#   lapply(htmltools::HTML)

# if the label required a suffix instead of a prefix, for example a %, the code would look like this:
# labels <- sprintf(
#   "Census tract: <em>%s</em><br/><strong>%s</strong>", data_tract$Census.Tract,
#   paste(prettyNum((round(data_tract$estimate, digits=2)), #the digits would probably be 2 for %
#               big.mark = ","), #this wouldn't be necessary to include for %s    
#         '%')) %>%
#   lapply(htmltools::HTML)

# map settings
tract_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  addPolygons(data=data_tract,
              fillColor = psrc_palette(data_tract$estimate),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = var_name,
              # label = round(data_tract$estimate, digits=1),
              label = labels) %>%

  # legends
  addLegend_decreasing(pal = psrc_palette,
                       values = data_tract$estimate,
                       position = "bottomright",
                       title = var_name,
                       group = var_name,
                       opacity = 0.7,
                       decreasing = TRUE,
                       labFormat = labelFormat()) %>% 
  
  #set view extent
  leaflet::setView(lng=map.lon, lat=map.lat, zoom=map.zoom) %>% 
  addEasyButton(easyButton(
    icon = htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  #&#127760; (another emoji option) #"fa-globe", (font awesome icon no longer works because of the conversion to Poppins font below)   
    title ="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
tract_map %<>% htmlwidgets::prependContent(html_fix)

# print map
tract_map
```

```{r, include=FALSE}
website_dev_folder <- '//WEB/website_data/equity-tracker-webpages/economy/med-income/'
map_name <- 'lifeexpec20.html'
  
# interactive webpage output process
htmlwidgets::saveWidget(tract_map,
                        file=paste0(website_dev_folder, map_name))
```
\
\

#### Data call outs
```{r, include=FALSE, eval=FALSE}
# calculate call out information
data_tract_calc <- data_tract %>%
  mutate(life.expectancy.wgt=(sum(estimate*total_pop20, na.rm =TRUE))/(sum(total_pop20, na.rm=TRUE)))
# regional average life expectancy: 78.79492

x<-rep(data_tract_calc$estimate,times=data_tract_calc$total_pop20)
df1<-data.frame(x)
summary(df1$x)
median(df1$x, na.rm=TRUE)
hist(df1$x)
# regional median life expectancy: 80.81  

data <- data_tract %>%
  st_drop_geometry()

sort <- data %>% 
  dplyr::arrange(desc(estimate))
# 3 highest: 53053070316 (Auburn) Pierce (95.39), 53033004401 (Roosevelt) and 53033004402 (U-district) King (92.14)

sort <- data %>% 
  dplyr::arrange(estimate)

# 3 lowest: 53053061900 (Tacoma-Lincoln International District) Pierce (67.31), 53053071806 (Lakewood) Pierce (69.74), (Tulalip Reservation) 53061940002 Snohomish (70.10)

#95.39-67.31=28.08
```

1. 78.8 years: The region's average life expectancy
2. 80.8 years: The region's median life expectancy
3. 28.1 years: The difference in the number of years between those living in the census tracts with the highest and lowest life expectancy

\

#### Insights & Analysis

* 
* 
* 
* 

\
\

## 2. Facet of most recent data
### a.) 
### b.) 
```{r, include=FALSE}
# # Elmer equity quintile tracts 
# equity_tracts <- get_table(schema="equity", tbl_name="v_tract_shares")
# 
# # filter for data year of interest
# equity_tracts_20 <- equity_tracts %>% 
#   dplyr::filter(data_year==2020)
# 
# 
# # join WTN health data WITH crosswalk to equity quintiles
# health_risk_equity_tracts <- merge(health_risk_crosswalk, equity_tracts_20,
#                                    by.x="geoid20",
#                                    by.y="geoid", # this will need to be adjusted based on the field name
#                                    all.x=TRUE)
# 
# # join WTN health data WIHTOUT crosswalk to equity quintiles
# health_risk_equity_tracts <- merge(data_csv, equity_tracts_20,
#                                    by.x="Census.Tract", # this will need to be adjusted based on the field name
#                                    by.y="geoid", 
#                                    all.x=TRUE)
```