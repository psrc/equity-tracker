---
title: "2.) Voter Turnout: 2020"
subtitle: "Applying geography splits to translate precinct-level data to census tract geographies"
author: "Mary Richards"
date: today
date-format: long
format: 
  html:
    toc: true
    toc-location: right-body
    toc-expand: 2
    # toc-depth: 6
    toc-title: "Contents"
execute:
  # echo: false
  warning: false
  error: false
---

This documents the process for exploring voter turnout based on data from the WA Secretary of State. In this exercise, we are using precinct-tract geography splits to calculate voter turnout by tract geographies.  
\
The final output is voter turnout (%) by census tract. Ultimately, this measurement will be used in the Equity Tracker and Displacement Risk Mapping projects.
```{r setup, include=FALSE}
# Read in Libraries
library(magrittr)
library(stringr)
library(data.table)
library(tidycensus)
library(tidyverse)
library(openxlsx)
library(psrcelmer)
library(psrccensus)

library(sf)
library(leaflet)
library(leafem) #home button
library(psrcplot)
library(here)

library(readxl)

# reference supplemental script with supporting settings/functions
# source(here::here('GitHub/equity-tracker/data-visualization/equity-tracker-supplemental-script.R'))
source('C:/Users/mrichards/Documents/GitHub/equity-tracker/data-visualization/equity-tracker-supplemental-script.R')
```

```{r, include=FALSE}
# Helper functions
fetch_turnout <- function(zip_url, data_file){
  temp_zip <- tempfile(fileext = ".zip")
  temp_dir <- tempdir()
  
  # Download the zip file
  download.file(zip_url, temp_zip)
  
  # Extract the zip file
  unzip(temp_zip, exdir = temp_dir)
  
  # Read the Excel/CSV file
  data_file <- file.path(temp_dir, data_file)
  
  if (endsWith(data_file, ".xlsx")) {
    turnout_data <- read.xlsx(data_file)
  } else if (endsWith(data_file, ".csv")) {
    turnout_data <- read.csv(data_file)
  } else {
    print("data is a different file type")
  }
  
  # Clean up temporary files
  unlink(temp_zip)
  unlink(data_file)
  
  return(turnout_data)
}
```

::: panel-tabset
# Data 
## 1.) Elmer geography splits: precinct-tract
These data tables include the distribution of the total population based on OFM between voting precincts (2020, from SOS) and census tracts (2020). The 2024 and 2020 geography split numbers are weighted based on the 2023 and 2020 5y ACS tract estimates for adult 18+ population, respectively.
```{r}
sql20 <- "select *
    from general.get_any_geography_splits(
      'voter_precinct_2020', --@data_geog_type
      'tract20',              --@planning_geog_type
      2020,                   --@ofm_estimate_year
      2024,                   --@ofm_vintage
      2018)                   --@parcel_year"

df20_adult <- get_query(sql=sql20, db_name = "Elmer")
```

## 2.) Secretary of State: turnout data
These data sets include the number of registered voters and the number of ballots cast by voting precinct. The voting precinct geographies change between election years. 
```{r}
voting_url <-"https://www.sos.wa.gov/sites/default/files/"

turnout_zip_url20 <- paste0(voting_url, "2024-02/2020Gen_Precinct_Results_GIS-Ready.zip") 


psrc_counties <- data.frame("CountyName"=c("King","Kitsap","Pierce","Snohomish"),
                            "FIPS"=c("033","035","053","061"),
                            "CountyCode" = c("KI", "KI", "PI", "SN"))

# Load voter turnout data using new source and column names
vt20 <- fetch_turnout(turnout_zip_url20, 
                      '2020Gen_Precinct_Turnout_GIS-Ready.xlsx')

# Clean turnout data sets - filter to PSRC region, rename columns
vt20_df <- vt20 %>% setDT() %>%                                             
  .[County %in% psrc_counties$CountyName] %>%                   # Filter to PSRC counties
  .[, .(county = County, precinctcode = PrecCode, precinctname = PrecName, 
        reg_voters = G20TREGVOT, ballots_cast = G20TBALCST)]

# 2020 precinct spatial data
# https://www.sos.wa.gov/elections/data-research/reports-data-and-statistics/precinct-shapefiles
folder <- "Y:/Equity Indicators/tracker-webpage-content/h-public-services/h02-voter-participation/raw-data/Statewide_Precincts_2020General"

precinct_20 <- st_read(file.path(folder, "Statewide_Precincts_2020General.shp"))
```

## 3.) Decennial census (2020) population data
These values will be used for the denominator - dividing the ballots cast by the total population 18+ or weighting the total population (OFM SAEP) by the ratio of adult 18+/total population estimates.
```{r}
## acs 5y
# base_acs_data <- get_acs_recs(geography ='tract',
#                               table.names = 'S0101', #subject table code
#                               years = c(as.numeric(acs_year)),
#                               acs.type = 'acs5')
# 
# # calculate the proportion of 18+ adults/total population to check if there are some tracts with more/fewer adults
# age_18over_total <- base_acs_data %>%
#   filter(variable=="S0101_C01_001" | #Total population
#            variable=="S0101_C01_026") %>% #Total population!!SELECTED AGE CATEGORIES!!18 years and over
#   select(GEOID, variable, estimate, year) %>%
#   pivot_wider(names_from = c(variable),
#               values_from = estimate) %>%
#   reframe(GEOID,
#           year,
#           pop_18=S0101_C01_026,
#           pop_tot=S0101_C01_001,
#           pop18_total=S0101_C01_026/S0101_C01_001)
# 
# # separate out years
# age_18over_total_23 <- age_18over_total %>% 
#   filter(year==2023)
# 
# age_18over_total_20 <- age_18over_total %>% 
#   filter(year==2020)

## decennial census
base_acs_data <- get_decennial_recs(geography='tract',
                                    table_codes = "DP1",
                                    sumfile = "dp",
                                    years=2020)

# filter variables based on: http://aws-linux/mediawiki/index.php/Decennial_Variables_2020#DP1
age_18over_total <- base_acs_data %>% 
  filter(variable=="DP1_0001C" | #Count:SEX AND AGE:Total population
           variable=="DP1_0021C") %>% #Count:SEX AND AGE:Total population:Selected Age Categories:18 years and over
  select(GEOID, variable, value, year) %>% 
  pivot_wider(names_from = c(variable),
              values_from = value) %>% 
  reframe(GEOID,
          year,
          pop_18=DP1_0021C,
          pop_tot=DP1_0001C,
          pop18_total=DP1_0021C/DP1_0001C)
```

## 4.) PSRC Region spatial file
This data set includes the census tracts within the region and provides a way to visually explore the voter turnout values. 
```{r, echo=FALSE}
# Connecting to ElmerGeo for census geographies through Portal----
arc_service <- "https://services6.arcgis.com/GWxg6t7KXELn1thE/arcgis/rest/services"

tracts20.url <- file.path(arc_service, "Census_Tracts_2020/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")
tracts10.url <- file.path(arc_service, "Census_Tracts_2010/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson")

tracts20.lyr <- st_read(tracts20.url)
tracts10.lyr <- st_read(tracts10.url)
```

## 5.) OFM small area estimates (2020) population data
These values will be used as the denominator for the fourth approach - dividing the ballots cast by the total population (OFM - Small Area Demographic Estimates, 2020), weighted by the proportion of adults 18+/total population from 2020 decennial census estimates.
```{r}
# OFM Small Estimates Program: https://ofm.wa.gov/washington-data-research/population-demographics/population-estimates/small-area-estimates-program
# folder_loc <- here::here("data_development/voter_turnout")
folder_loc <- "C:/Users/mrichards/Documents/GitHub/equity-tracker/data_development/voter_turnout"


ofm_raw <- read_excel(file.path(folder_loc,
                                "saep_tract20.xlsx"),
                      sheet = "Total Population",
                      skip=10) #first rows includes metadata

# clean data set
ofm_psrc <- ofm_raw %>% 
  select(`County Name`, `Census Tract Code Complete`, 
         `OFM Adjusted Total Population 2020`,
         `Estimated Total Population 2024`) %>% 
  rename("County_Name"=`County Name`,
         "GEOID20"=`Census Tract Code Complete`,
         "population_2020"=`OFM Adjusted Total Population 2020`,
         "population_2024"=`Estimated Total Population 2024`) %>% 
  filter(County_Name=='King' |
           County_Name=='Kitsap' |
           County_Name=='Pierce' |
           County_Name=='Snohomish')

```

# Methods
**Voter turnout = ballots cast / eligible population** 
\
The main challenge is that the raw voting data is available at voting precincts, which are unique geographies that do not align with census geographies. This requires translation between the two geographies. 
\
\
For the 2024 election data, we calculated voter turn out based on earlier exploration (testing 4 methods). The numerator is calculated by weighting the population distribution (based on OFM) by ACS 2023 5y adult 18+ population estimates (TRACT). The denominator is calculated by using OFM Small Area Program Estimate (SAPE) 2024 total population estimates (TRACT), weighted by the ACS 2023 5y adult 18+ population/total population ratio (TRACT).
\
\
For the 2020 election data, the numerator is calculated by weighting the population distribution (based on OFM) by ACS 2020 5y adult 18+ population estimates (TRACT). We are exploring two approaches to calculate the denominator (the eligible voting age population):

A) OFM Small Area Program Estimate 2020 total population (TRACT), weighted by the 2020 decennial census  adult 18+ population/total population ratio (TRACT) - same approach as used for 2024, but using decennial census instead of ACS 2023 5y estimates
B) 2020 decennial census  adult 18+ population estimates (TRACT)


*DATA CAVEATS:* 

* For this exercise, it is assumed that the eligible population most closely aligns with the adult 18+ population. Although this may include individuals who are not able to legally vote (non-citizens), the alternative is using the number of registered voters (available at voting precincts), which is a subset of the adult 18+ population who are already engaged enough to have registered. While using the general 18+ population as a denominator may result in slightly lower voter turnout values (based on our working definition), using registered voters as the denominator would results in inflated voter turnout values.
* Some voters may be registered in one location, but reside in another. This could cause mismatches in the way that they are accounted for in the numerator (ballots cast) and the denominator (population). 
* There is a distinction between residential addresses (which must be in Washington State and where you are considered registered for voting purposes) and mailing addresses (which can be anywhere). Therefore, the number of registered voters refers to the number of voters who have their residential address in that precinct. This is based on correspondence with staff at the Washington Secretary of State office (8/13/2025).
* According to correspondences with staff at the Washington Secretary of State office (10/9/2025), data from smaller precincts are occasionally “masked” into a larger precinct in order to protect the privacy of voters and maintain confidentiality. It is also possible for last minuet ballots to be cast (such as by UOCAVA voters, or Military and Overseas Voters, defined by https://www.eac.gov/uocava) that must be accorded to a precinct. As a result, the voter turnout results calculated at the tract level are estimates and may reflect some margin of error. 


# Reference Maps
## Voting precints (2020) and census tracts (2020)
```{r, echo=FALSE}
# map settings
tract_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  leaflet::addLayersControl(baseGroups = "voting precincts (2020)",
                   overlayGroups = "census tracts (2020)",
                   options = layersControlOptions(collapsed = FALSE)) %>%
  
  addPolygons(data=precinct_20,
              color = "gray",
              stroke=TRUE, 
              weight = 3,
              smoothFactor = 0.5,
              fillOpacity = 0,
              group = "voting precincts (2020)",
              label = precinct_20$St_Code) %>%
  addPolygons(data=tracts20.lyr,
              color = "blue",
              stroke = TRUE, 
              weight = 2.5,
              smoothFactor = 0.5,
              fillOpacity = 0,
              group = "census tracts (2020)",
              label = tracts20.lyr$geoid20) %>% 

  #set view extent
  leaflet::setView(lng=-122.257, lat=47.615, zoom=8.5) %>%
  addEasyButton(easyButton(
    icon = htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  #&#127760; (another emoji option) #"fa-globe", (font awesome icon no longer works because of the conversion to Poppins font below)
    title ="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
tract_map %<>% htmlwidgets::prependContent(html_fix)

# print map
tract_map
```

## 2020 voter participation (ballots cast/registered voters)
```{r}
# join voting data to precinct spatial layer 
join_voting20 <- precinct_20 %>% 
  right_join(vt20_df,
            by = c('St_Code'='precinctcode'))

# calculate the ballots cast/registered voters for reference numbers
voting_20 <- join_voting20 %>% 
  mutate(vote_participation=(ballots_cast/reg_voters)*100)

summary(voting_20$vote_participation)
```

The max is higher than 100% indicating some issues with the raw data from SOS.
```{r}
highest_15 <- voting_20 %>%
  st_drop_geometry() %>% 
  arrange(desc(vote_participation)) %>% 
  slice_head(n = 15) %>% 
  select(St_Code, ballots_cast, reg_voters, vote_participation) %>% 
  print
```
According to an email (10/9/2025) with the Secretary of State (vrsupport@sos.wa.gov), "there are few reasons why that might occur. For example, precincts which have a very small number of voters are “masked” into a larger precinct in order to prevent someone from deducing who they voted for; it is also possible for last minuet ballots to be cast (perhaps by a UOCAVA voter) that must be accorded to a precinct. In your screenshot, Kitsap 166 CP9 is the real issue, and I think that is just human error. The votes and ballots cast from 102 CP9 -2 got “mapped” to precinct 166 CP9 rather than 102 CP9. The results for 166 CP9 plus 102 CP9 should be accurate (they are neighboring precincts)."

### investigate precincts
```{r}
prec_ki <- voting_20 %>% 
  filter(St_Code == "KP00000166" |
           St_Code == "KP00000102")
```

```{r, echo=FALSE}
# map settings
tract_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  leaflet::addLayersControl(baseGroups = "voting precincts (2020)",
                   overlayGroups = c("census tracts (2020)", "Kitsap issue precincts"),
                   options = layersControlOptions(collapsed = FALSE)) %>%
  
  addPolygons(data=precinct_20,
              color = "gray",
              stroke=TRUE, 
              weight = 3,
              smoothFactor = 0.5,
              fillOpacity = 0,
              group = "voting precincts (2020)",
              label = precinct_20$St_Code) %>%
  addPolygons(data=tracts20.lyr,
              color = "blue",
              stroke = TRUE, 
              weight = 2.5,
              smoothFactor = 0.5,
              fillOpacity = 0,
              group = "census tracts (2020)",
              label = tracts20.lyr$geoid20) %>%
  addPolygons(data=prec_ki,
              color = "red",
              stroke = TRUE, 
              weight = 2.5,
              smoothFactor = 0.5,
              fillOpacity = 0,
              group = "Kitsap issue precincts",
              label = paste(prec_ki$St_Code, ": ", prec_ki$vote_participation)) %>%

  #set view extent
  leaflet::setView(lng=-122.257, lat=47.615, zoom=8.5) %>%
  addEasyButton(easyButton(
    icon = htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  #&#127760; (another emoji option) #"fa-globe", (font awesome icon no longer works because of the conversion to Poppins font below)
    title ="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
tract_map %<>% htmlwidgets::prependContent(html_fix)

# print map
tract_map
```

There are also some precincts with 0 ballots cast.
```{r}
lowest_10 <- voting_20 %>%
  st_drop_geometry() %>% 
  arrange(vote_participation) %>% 
  slice_head(n = 10) %>% 
  select(St_Code, ballots_cast, reg_voters, vote_participation) %>% 
  print
```

This map shows the ballots cast/registered voters. The legend starts at 0% because there are 2 precincts where no ballots were cast. It is important to note that these precincts also have quite low numbers of registered voters.
```{r, echo=FALSE}
# set up palettes
psrc_palette <- leaflet::colorNumeric(palette=psrc_colors$purples_inc,
                                      domain = voting_20$vote_participation)

# map settings
tract_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  leaflet::addLayersControl(baseGroups = "voter participation",
                   options = layersControlOptions(collapsed = FALSE)) %>%
  
  addPolygons(data=voting_20,
              fillColor = psrc_palette(voting_20$vote_participation),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = "voter participation",
              label = paste(round(voting_20$vote_participation, digits=0),"%")) %>%
  # legends
  addLegend_decreasing(pal = psrc_palette,
                       values = voting_20$vote_participation,
                       position = "bottomright",
                       title = "Voter Participation",
                       group = "voter participation",
                       opacity = 0.7,
                       decreasing = TRUE,
                       labFormat = labelFormat(suffix = "%")) %>% 

  #set view extent
  leaflet::setView(lng=-122.257, lat=47.615, zoom=8.5) %>%
  addEasyButton(easyButton(
    icon = htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  #&#127760; (another emoji option) #"fa-globe", (font awesome icon no longer works because of the conversion to Poppins font below)
    title ="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
tract_map %<>% htmlwidgets::prependContent(html_fix)

# print map
tract_map
```


# A) Adult population by tract (OFM SAEP 2020; 2020 decennial census)
## Join precinct-tract to geographies to turnout data
```{r}
nrow(df20_adult) #precinct-tract records: 5912
nrow(vt20_df) #voting data by unique precinct: 4196
vt20_df_0 <- vt20_df %>% 
  filter(reg_voters<1) # there are 30 precincts without data
# data_geog = precinct
# planning_geog = tract
length(unique(df20_adult$data_geog)) #unique precincts: 4169
length(unique(df20_adult$planning_geog)) #unique tracts: 919
```
There is a difference in the number of records - in the voting data, there are 4,169 records (precincts) while the geography split data only has 4,169 unique precincts. The difference between these two data sets is 27 precincts. There are 30 precincts in the voting data without registered voters.

## calculate total numbers for reference 
```{r}
sum(vt20_df$reg_voters) #2,706,778
sum(vt20_df$ballots_cast) #2,288,765
```
In the 2020 voting data (by precinct), there were 2,706,778 registered voters and 2,288,765 ballots cast.  

## join voter turnout data to precinct-tract splits on precinct field
Using a full_join()
```{r}
join_df20 <- df20_adult %>% 
  full_join(vt20_df, 
            by = c('data_geog'='precinctcode')) #5941 records


# simplify data - remove unnecessary fields
join_df20_simp <- join_df20 %>% 
  select(-c(percent_of_group_quarters_pop, 
            percent_of_household_pop, 
            percent_of_housing_units,
            percent_of_occupied_housing_units))

# review data
summary(join_df20_simp$reg_voters) #61 NAs
summary(join_df20_simp$ballots_cast) #61 NAs

# calculate weighted registered voters and ballots cast 
df20_calc <- join_df20_simp %>% 
  mutate(reg_voters_wt = reg_voters*percent_of_total_pop,
         ballots_cast_wt = ballots_cast*percent_of_total_pop)

# check totals
sum(df20_calc$reg_voters_wt, na.rm=TRUE) #2706774 - 4 missing
sum(df20_calc$ballots_cast_wt, na.rm=TRUE) #2288762 - 3 missing
```

## join tract level OFM estimates to decennial census adult 18+ ratio
```{r}
tract_population <- ofm_psrc %>% 
  left_join(age_18over_total, by= c("GEOID20"="GEOID"))

# weighting the OFM population estimates by decennial census 18+/total proportion, 
tract_pop_18plus <- tract_population %>% 
  mutate(population_18plus=round(as.numeric(population_2020)*pop18_total,0))
```

## calculate voter turnout by registered voters 
(ballots cast/registered voters)
\
This is not the final calculation because it is based on those who are already engaged to an extent, not the general population who are capable of voting.
```{r}
df20_calc_tract <- df20_calc %>% 
  mutate(reg_voters_wt = case_when(is.na(reg_voters_wt)~0, # need to convert NA to 0 so they can be added
                                   TRUE ~ reg_voters_wt), # if this isn't included, when they're grouped, the NA's will cancel out the other values within the census tract
         ballots_cast_wt = case_when(is.na(ballots_cast_wt)~0,
                                     TRUE ~ ballots_cast_wt)) %>% 
  group_by(data_geog_type, planning_geog_type, 
           ofm_estimate_year, ofm_vintage, parcel_year,
           planning_geog) %>% # grouping on tract ids, retaining other fields for reference
  summarise(#reg_voters = sum(reg_voters_wt), # need to round?
            # ballots_cast = sum(ballots_cast_wt), # need to round?
            reg_voters = round(sum(reg_voters_wt), digits = 0),
            ballots_cast = round(sum(ballots_cast_wt), digits = 0),
            .groups = 'drop') %>% 
  mutate(regvote_turnout = ballots_cast/reg_voters)

# calculate total numbers to check
sum(df20_calc_tract$reg_voters, na.rm=T) #2706766 when rounded
sum(df20_calc_tract$ballots_cast, na.rm=T) #2288758 when rounded
```

## calculate voter turnout by population 18+ 
(ballots cast/pop 18+)
\
This is closer to the final calculation because it takes into account all people who are capable of voting. This value may include non-citizens, or adults 18+ who are not legally allowed to vote, but it is more comprehensive than just considering those who are registered. The denominator will be based on OFM population estimates (2024), weighted by the ratio of adults 18+/total population from ACS (2023). 
```{r}
# join to precinct/voter turnout data to tract 18+ population data (OFM/ACS) to calculate population 18+ turnout
df20_calc_tract_adults_ofm <- df20_calc_tract %>% 
  left_join(tract_pop_18plus, by = c('planning_geog'='GEOID20')) 
  

# calculate voter turnout by population 18+
df20_tract_adult_ofm <- df20_calc_tract_adults_ofm %>% 
  mutate(pop18_turnout = ballots_cast/population_18plus,
         registered_pop18 = reg_voters/population_18plus)

# check 
summary(df20_tract_adult_ofm$pop18_turnout) #1.01164 max
summary(df20_tract_adult_ofm$registered_pop18) #1.09840 max
```
There are tracts with higher than 100% voter turnout and higher than 100% registered voters. 

### Checking tracts with over 100%
#### where # of ballots cast is greater than the number of adults 18+
```{r}
df20_tract_adult_ofm_simp <- df20_tract_adult_ofm %>% 
  select(planning_geog, ballots_cast, population_18plus, pop18_turnout)

df20_tract_above1_adultpop_ofm <- df20_tract_adult_ofm_simp %>% 
  filter(pop18_turnout>1)

df20_tract_above1_adultpop_ofm

df20_tract_above1_adultpop_ofm_simp <- df20_tract_above1_adultpop_ofm %>% 
  select(planning_geog, ballots_cast, population_18plus, pop18_turnout)
```
There are 2 tracts over 100%.

##### map of tracts by voter turnout
```{r}
# join full data to tract spatial file
df20_tract_adult_ofm_geo <- merge(tracts20.lyr, df20_tract_adult_ofm,
                              by.x="geoid20",
                              by.y="planning_geog", 
                              all.x=TRUE)

df20_tract_adult_ofm_geo <- df20_tract_adult_ofm_geo %>% 
  mutate(pop18_turnout=pop18_turnout*100)

# filter to tracts >100%
df20_tract_adult_ofm_geo_100plus <- df20_tract_adult_ofm_geo %>% 
  filter(pop18_turnout>100)
```

```{r, echo=FALSE}
# set up palettes
psrc_palette <- leaflet::colorNumeric(palette=psrc_colors$purples_inc,
                                      domain = df20_tract_adult_ofm_geo$pop18_turnout)

# map settings
tract_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  leaflet::addLayersControl(baseGroups = "voter participation",
                   overlayGroups = c("tracts >100%", "voting precincts (2020)"),
                   options = layersControlOptions(collapsed = FALSE)) %>%
  
  addPolygons(data=df20_tract_adult_ofm_geo,
              fillColor = psrc_palette(df20_tract_adult_ofm_geo$pop18_turnout),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = "voter participation",
              label = paste(round(df20_tract_adult_ofm_geo$pop18_turnout, digits=0),"%")) %>%
  # addPolygons(data=precinct_20,
  #             color = "gray",
  #             stroke=TRUE, 
  #             weight = 3,
  #             smoothFactor = 0.5,
  #             fillOpacity = 0,
  #             group = "voting precincts (2020)",
  #             label = precinct_20$St_Code) %>%
  addPolygons(data=df20_tract_adult_ofm_geo_100plus,
              color = "red",
              stroke = TRUE, 
              weight = 3,
              smoothFactor = 0.5,
              fillOpacity = 0,
              group = "tracts >100%",
              label = paste(round(df20_tract_adult_ofm_geo_100plus$pop18_turnout, digits=0),"%")) %>% 
   

  # legends
  addLegend_decreasing(pal = psrc_palette,
                       values = df20_tract_adult_ofm_geo$pop18_turnout,
                       position = "bottomright",
                       title = "Voter Participation",
                       group = "voter participation",
                       opacity = 0.7,
                       decreasing = TRUE,
                       labFormat = labelFormat(suffix = "%")) %>% 

  #set view extent
  leaflet::setView(lng=-122.257, lat=47.615, zoom=8.5) %>%
  addEasyButton(easyButton(
    icon = htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  #&#127760; (another emoji option) #"fa-globe", (font awesome icon no longer works because of the conversion to Poppins font below)
    title ="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
tract_map %<>% htmlwidgets::prependContent(html_fix)

# print map
tract_map
```

#### where # of registered voters is greater than the number of adults 18+
```{r}
df20_tract_adult_ofm_simp_reg <- df20_tract_adult_ofm %>% 
  select(planning_geog, ballots_cast, population_18plus, pop18_turnout, registered_pop18)

df20_tract_above1_adultpop_reg <- df20_tract_adult_ofm_simp_reg %>% 
  filter(registered_pop18>1)

df20_tract_above1_adultpop_reg
```
There are 58 tracts over 100%.


# B) Adult population by tract (decennial census, 2020)
## Join precinct-tract to geographies to turnout data
```{r}
nrow(df20_adult) #precinct-tract records: 5912
nrow(vt20_df) #voting data by unique precinct: 4196
vt20_df_0 <- vt20_df %>% 
  filter(reg_voters<1) # there are 30 precincts without data
# data_geog = precinct
# planning_geog = tract
length(unique(df20_adult$data_geog)) #unique precincts: 4169
length(unique(df20_adult$planning_geog)) #unique tracts: 919
```
There is a difference in the number of records - in the voting data, there are 4,169 records (precincts) while the geography split data only has 4,169 unique precincts. The difference between these two data sets is 27 precincts. There are 30 precincts in the voting data without registered voters.


## calculate total numbers for reference 
```{r}
sum(vt20_df$reg_voters) #2,706,778
sum(vt20_df$ballots_cast) #2,288,765
```
In the 2020 voting data (by precinct), there were 2,706,778 registered voters and 2,288,765 ballots cast.  

## join voter turnout data to precinct-tract splits on precinct field
Using a full_join()
```{r}
join_df20 <- df20_adult %>% 
  full_join(vt20_df, 
            by = c('data_geog'='precinctcode')) #6351 records


# simplify data - remove unnecessary fields
join_df20_simp <- join_df20 %>% 
  select(-c(percent_of_group_quarters_pop, 
            percent_of_household_pop, 
            percent_of_housing_units,
            percent_of_occupied_housing_units))

# review data
summary(join_df20_simp$reg_voters) #61 NAs
summary(join_df20_simp$ballots_cast) #61 NAs

# calculate weighted registered voters and ballots cast 
df20_calc <- join_df20_simp %>% 
  mutate(reg_voters_wt = reg_voters*percent_of_total_pop,
         ballots_cast_wt = ballots_cast*percent_of_total_pop)
```

## calculate total numbers to check 
These calculations sum the values after being weighted by the geography splits. They should match the original voting precinct data. 
```{r}
sum(df20_calc$reg_voters_wt, na.rm = TRUE) #2,706,774 ~ 4 missing voters?
sum(df20_calc$ballots_cast_wt, na.rm = TRUE) #2,288,762 ~ 3 missing ballots cast

# does rounding make a difference?
round(sum(df20_calc$reg_voters_wt, na.rm = TRUE), digits = 0) #2,706,774 ~ still 4 missing voters
round(sum(df20_calc$ballots_cast_wt, na.rm = TRUE), digits =0) #2,288,762 ~ still 3 missing ballots cast
```

## calculate voter turnout by registered voters 
(ballots cast/registered voters)
\
This is not the final calculation because it is based on those who are already engaged to an extent, not the general population who are capable of voting.
```{r}
df20_calc_tract <- df20_calc %>% 
  mutate(reg_voters_wt = case_when(is.na(reg_voters_wt)~0, # need to convert NA to 0 so they can be added
                                   TRUE ~ reg_voters_wt), # if this isn't included, when they're grouped, the NA's will cancel out the other values within the census tract
         ballots_cast_wt = case_when(is.na(ballots_cast_wt)~0,
                                     TRUE ~ ballots_cast_wt)) %>% 
  group_by(data_geog_type, planning_geog_type, 
           ofm_estimate_year, ofm_vintage, 
           planning_geog) %>% # grouping on tract ids, retaining other fields for reference
  summarise(#reg_voters = sum(reg_voters_wt), # need to round?
            # ballots_cast = sum(ballots_cast_wt), # need to round?
            reg_voters = round(sum(reg_voters_wt), digits = 0),
            ballots_cast = round(sum(ballots_cast_wt), digits = 0),
            .groups = 'drop') %>% 
  mutate(regvote_turnout = ballots_cast/reg_voters)

# calculate total numbers to check
sum(df20_calc_tract$reg_voters, na.rm=T) #2,706,766 when rounded
sum(df20_calc_tract$ballots_cast, na.rm=T) #2,288,758 when rounded
```

## calculate voter turnout by population 18+ 
(ballots cast/pop 18+)
\
This is closer to the final calculation because it takes into account all people who are capable of voting. This value may include non-citizens, or adults 18+ who are not legally allowed to vote, but it is more comprehensive than just considering those who are registered.
```{r}
# simplify acs table and join to voter/ballot data
age_18over_simp <- age_18over_total %>% 
  select(GEOID, 
         year,
         pop_18)

# join to precinct/voter turnout data to tract 18+ population data to calculate population 18+ turnout
df20_calc_tract_adults <- df20_calc_tract %>% 
  left_join(age_18over_simp, 
            by = c('planning_geog'='GEOID')) 
  

# calculate voter turnout by population 18+
df20_tract_adult <- df20_calc_tract_adults %>% 
  mutate(pop18_turnout = ballots_cast/pop_18,
         registered_pop18 = reg_voters/pop_18)

# check 
summary(df20_tract_adult$pop18_turnout) #1.01164 max
summary(df20_tract_adult$registered_pop18) #1.09840 max
```
There are some tracts with higher than 100% voter turnout and registered voters. 

### Checking tracts with over 100%
#### where # of ballots cast is greater than the number of adults 18+
```{r}
df20_tract_adult_simp <- df20_tract_adult %>% 
  select(planning_geog, ballots_cast, pop_18, pop18_turnout)

df20_tract_above1_adultpop <- df20_tract_adult_simp %>% 
  filter(pop18_turnout>1)

df20_tract_above1_adultpop
```
There are 2 tracts over 100%.

##### map of tracts >100% voter turnout
```{r}
# join full data to tract spatial file
df20_tract_adult_geo <- merge(tracts20.lyr, df20_tract_adult,
                              by.x="geoid20",
                              by.y="planning_geog", 
                              all.x=TRUE)

df20_tract_adult_geo <- df20_tract_adult_geo %>% 
  mutate(pop18_turnout=pop18_turnout*100)

# filter to tracts >100%
df20_tract_adult_dec_geo_100plus <- df20_tract_adult_geo %>% 
  filter(pop18_turnout>100)
```

```{r, echo=FALSE}
# set up palettes
psrc_palette <- leaflet::colorNumeric(palette=psrc_colors$purples_inc,
                                      domain = df20_tract_adult_geo$pop18_turnout)

# map settings
tract_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  leaflet::addLayersControl(baseGroups = "voter participation",
                   overlayGroups = "tracts >100%",
                   options = layersControlOptions(collapsed = FALSE)) %>%
  
  addPolygons(data=df20_tract_adult_geo,
              fillColor = psrc_palette(df20_tract_adult_geo$pop18_turnout),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = "voter participation",
              label = paste(round(df20_tract_adult_geo$pop18_turnout, digits=0),"%")) %>%
  addPolygons(data=df20_tract_adult_dec_geo_100plus,
              color = "red",
              stroke = TRUE, 
              weight = 3,
              smoothFactor = 0.5,
              fillOpacity = 0,
              group = "tracts >100%",
              label = paste(round(df20_tract_adult_dec_geo_100plus$pop18_turnout, digits=0),"%")) %>% 

  # legends
  addLegend_decreasing(pal = psrc_palette,
                       values = df20_tract_adult_geo$pop18_turnout,
                       position = "bottomright",
                       title = "Voter Participation",
                       group = "voter participation",
                       opacity = 0.7,
                       decreasing = TRUE,
                       labFormat = labelFormat(suffix = "%")) %>% 

  #set view extent
  leaflet::setView(lng=-122.257, lat=47.615, zoom=8.5) %>%
  addEasyButton(easyButton(
    icon = htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  #&#127760; (another emoji option) #"fa-globe", (font awesome icon no longer works because of the conversion to Poppins font below)
    title ="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
tract_map %<>% htmlwidgets::prependContent(html_fix)

# print map
tract_map
```

#### where # of registered voters is greater than the number of adults 18+
```{r}
df20_tract_above1_adultpop_reg <- df20_tract_adult %>% 
  filter(registered_pop18>1)

df20_tract_above1_adultpop_reg
```
There are 58 tracts over 100%.

# Conclusions
## Overall
Out of the two methods explored above, the first approach appears to be the best, primarily because of consistency with calculating the 2024 voter turn out numbers. 

## Process
We tested the second approach to determine if using adult 18+ population estimates from the decennial census would yield similar results to the first method. In both cases, there were 2 census tracts that had over 100% voter turnout - the same tracts on Bainbridge Island. 

We also tested the differences between the census tract population estimates - there were 2 tracts that differed between the 2 methods. These census tracts were in Snohomish County (Everett) and Pierce County (Bonney Lake). For both census tracts the OFM population estimates (weighted by 2020 decennial adult 18+/total population ratio) were lower than the 2020 decennial census 18+ population estimates, resulting in the OFM based voter turnout values being higher.   

## Summary of results
### 1st approach
#### All tracts
```{r}
summary(df20_tract_adult_ofm$pop18_turnout)
hist(df20_tract_adult_ofm$pop18_turnout)
```

#### Tracts with voter turnout over 100%
```{r}
df20_tract_above1_adultpop_ofm_simp %>% arrange(desc(pop18_turnout))

summary(df20_tract_above1_adultpop_ofm_simp$pop18_turnout)
hist(df20_tract_above1_adultpop_ofm_simp$pop18_turnout)
```

### 2nd approach
#### All tracts
```{r}
summary(df20_tract_adult$pop18_turnout)
hist(df20_tract_adult$pop18_turnout)
```

#### Tracts with voter turnout over 100%
```{r}
df20_tract_above1_adultpop %>% arrange(desc(pop18_turnout))

summary(df20_tract_above1_adultpop$pop18_turnout)
hist(df20_tract_above1_adultpop$pop18_turnout)
```

### Comparing two methods
```{r}
# joining the ofm/decennial and the decennial results
join_all <- df20_tract_adult_ofm_simp %>% 
  full_join(df20_tract_adult_simp,
            by=c("planning_geog"))

join_calc <- join_all %>% 
  mutate(dif_ofm_dec_voterturnout=pop18_turnout.x-pop18_turnout.y,
         dif_ofm_dec_pop18=population_18plus-pop_18,
         dif_ofm_dec_ballots=ballots_cast.x-ballots_cast.y)

summary(join_calc$dif_ofm_dec_voterturnout)
hist(join_calc$dif_ofm_dec_voterturnout)

summary(join_calc$dif_ofm_dec_pop18)
hist(join_calc$dif_ofm_dec_voterturnout)

summary(join_calc$dif_ofm_dec_ballots) #there shouldn't be a difference in the number of ballots cast

join_calc_simp <- join_calc %>% 
  select(planning_geog, dif_ofm_dec_voterturnout,
         dif_ofm_dec_pop18, dif_ofm_dec_ballots) %>% 
  arrange(desc(dif_ofm_dec_voterturnout)) %>% 
  print()
```

### Difference b/t OFM SAEP (2020) and 2020 decennial census population numbers
```{r}
dif_ofm_dec <- tract_pop_18plus %>% 
  mutate(difference_ofm_decnnial=population_2020-pop_tot)

summary(dif_ofm_dec$difference_ofm_decnnial)
```
There are two tracts that have a difference in the population numbers. 

#### map of tracts by voter turnout
```{r}
# join full data to tract spatial file
dif_ofm_dec_geo <- merge(tracts20.lyr, dif_ofm_dec,
                         by.x="geoid20",
                         by.y="GEOID20", 
                         all.x=TRUE)

dif_ofm_dec_geo <- dif_ofm_dec_geo %>% 
  mutate(pop18_perc=pop18_total*100)

# filter to tracts >100%
dif_ofm_dec_geo_over0 <- dif_ofm_dec_geo %>% 
  filter(difference_ofm_decnnial<0)
```

```{r, echo=FALSE}
# set up palettes
psrc_palette <- leaflet::colorNumeric(palette=psrc_colors$purples_inc,
                                      domain = dif_ofm_dec_geo$pop18_perc)

# map settings
tract_map <- leaflet() %>%
  leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
  leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
  leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
  leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                            options = leaflet::leafletOptions(pane = "maplabels"),
                            group = "Labels") %>%
  leaflet::addLayersControl(baseGroups = "Percent 18+",
                   overlayGroups = "dif > 0",
                   options = layersControlOptions(collapsed = FALSE)) %>%
  
  addPolygons(data=dif_ofm_dec_geo,
              fillColor = psrc_palette(dif_ofm_dec_geo$pop18_perc),
              stroke=FALSE, 
              smoothFactor = 0.2,
              fillOpacity = 0.7,
              group = "Percent 18+",
              label = paste(round(dif_ofm_dec_geo$pop18_perc, digits=0),"%")) %>%
  addPolygons(data=dif_ofm_dec_geo_over0,
              color = "red",
              stroke = TRUE, 
              weight = 3,
              smoothFactor = 0.5,
              fillOpacity = 0,
              group = "dif > 0",
              label = dif_ofm_dec_geo_over0$difference_ofm_decnnial) %>% 

  # legends
  addLegend_decreasing(pal = psrc_palette,
                       values = dif_ofm_dec_geo$pop18_perc,
                       position = "bottomright",
                       title = "Percent Population 18+",
                       group = "Percent 18+",
                       opacity = 0.7,
                       decreasing = TRUE,
                       labFormat = labelFormat(suffix = "%")) %>% 

  #set view extent
  leaflet::setView(lng=-122.257, lat=47.615, zoom=8.5) %>%
  addEasyButton(easyButton(
    icon = htmltools::span(class = "globe", htmltools::HTML("&#127758;")),  #&#127760; (another emoji option) #"fa-globe", (font awesome icon no longer works because of the conversion to Poppins font below)
    title ="Region",
    onClick=JS("function(btn, map){map.setView([47.615,-122.257],8.5); }")))

# fix the legend NA placement (https://github.com/rstudio/leaflet/issues/615)
css_fix <- "div.info.legend.leaflet-control br {clear: both;} html * {font-family: Poppins !important;}" # CSS to correct spacing and font family
html_fix <- htmltools::tags$style(type = "text/css", css_fix)  # Convert CSS to HTML
tract_map %<>% htmlwidgets::prependContent(html_fix)

# print map
tract_map
```
The two tracts where there is a difference: near Everett (Snohomish County) and Bonney Lake (Pierce County)